%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[utf8]{inputenc}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{enumerate}
\usepackage{a4wide}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=tbrl,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\usepackage[bottom=3cm]{geometry}

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{\vspace{-50pt}\textbf{Overlay Networks, Decentralized Systems and their Application}\\ Exercise 03 \\ University of Zurich} % Title

\author{Reto \textsc{Wettstein}\\12-716-221\\reto.wettstein2@uzh.ch \\ \\ Solved together with Christian \textsc{Tresch} 06-923-627} % Author name


\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date


\section{Bloom Filters}
\begin{enumerate}[1]
\item \textbf{Which operations does the traditional Bloom Filter support?} \\
	\textsc{Insertion}: The bit A[$h_{i}$(x)] for $1 < i < k$ are set to 1, where k is the number of hash. functions.\\
	\textsc{Query}: Yes if all of the bits A[$h_{i}$(x)] are 1, no otherwise.\\
	\textsc{Deletion}: Removing an element from a simple Bloom filter is impossible.\\
	\textsc{Union}: Bitwise OR of Bloom Filters.\\
	\textsc{Intersection}: Bitwise AND of Bloom Filters. 

\item \textbf{Does the Bloom Filter have a capacity limit? What changes if more and more elements are added?} \\ The Bloom Filter can represent the entire universe of elements (in this case all bits are 1) $\rightarrow$ no capacity limit  exists, an \textsc{Insertion} always works. If more and more elements are added, the rate of false-positive answers increases steadily. 

\item \textbf{What is a false positive? Explain how it can happen.} \\ A false-positive occurs, when the result of a query is yes, even if the element is not in the set. For example the insertion of hash('Computer') sets bits (1, 5, 7) to one and the insertion of hash('Science') sets bits (2, 4, 6) to one. Then the query hash('Machine') = (1, 2, 6) returns yes although 'machine' was never inserted into the filter.

\item \textbf{Can the traditional Bloom Filter have false negatives? Explain.} \\ No, the traditional Bloom Filter can have no false negatives. If the corresponding bits are set to one and match the query, the Bloom Filter always returns yes. Bits set to one can never change back to zero, because deletion is not possible.  

\item \textbf{Describe a real life application scenario for Bloom Filters and explain why they are useful in the chosen scenario?} \\ \textsc{Spell-Checking}: a Bloom filter is used to store a dictionary of correctly-spelled words. If hash('word') returns false, the spell checker flags word as a misspelling. False positives in this application, e.g., hash(‘notaword’) == True, results in some misspellings going unnoticed. Bloom filters allow the spell checking application to load a comprehensive dictionary into a small amount of memory and makes spell checking fast enough that users can run the checker often. The small memory footprint can be achieved with a false positive rate that results in approximately 1 in 100 misspellings going undetected. \\ 
\end{enumerate}

\section{Kademlia}
\begin{enumerate}[1]
\item \textbf{How many ID's are possible?} \\ A node ID has a length of 160 bit $\rightarrow$ $2^{160}$ $\approx$ 1.5 x $10^{48}$ different ID's are possible.

\item \textbf{Where is a key located?} \\ A key is located on the node whose ID is closest to the key.

\item \textbf{What is the XOR distance betweeen 3 and 4?} \\ 7 $\rightarrow$ $011_{2}$ XOR $100_{2}$ = $111_{2}$, which is $7_{10}$

\item \textbf{Kademlia routing tables consist of a list for each bit of the node ID. (e.g. if a node ID consists of 128 bits, a node will keep 128 such lists. In this case, would 127 lists be enough? Why?} \\ Yes, 127 lists would be enough because you don't need to know yourself. \\
\end{enumerate}

\section{Challenge Task Preparation}
This is my code for the programming task. The output looks like this: 
\begin{enumerate}[]
	\item PEER 3: stored [Key: Max Power, Value: paddr[0x3[/192.168.0.17,4001]]/relay(false)/slow(false)]
	\item PEER 5: looked up [Key: Max Power], received [Value: paddr[0x3[/192.168.0.17,4001]]/relay(false)/slow(false)]
	\item PEER 3: received [Message: Hello World] from peer 5
\end{enumerate}

\lstinputlisting{Main.java}

\lstinputlisting{DHTOperations.java}

\lstinputlisting{SendOperations.java}

\end{document}